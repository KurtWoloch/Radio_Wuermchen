# Dynamic Segment Streamer (Pipe-Writer Mode with Local SAPI TTS)\n\nimport subprocess\nimport time\nimport os\nimport random\nfrom itertools import cycle\nimport re\nimport json\n\n# --- CONFIGURATION ---\nSCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))\n\nPLAYLIST_FILE = os.path.join(SCRIPT_DIR, \"music.playlist\")\nFFMPEG_BIN = \"C:/msys64/mingw64/bin/ffmpeg.exe\"\nCONCAT_LIST_PATH = os.path.join(SCRIPT_DIR, \"temp_concat.txt\") \n\n# Path for the temporary text and audio files\nANNOUNCEMENT_TEXT_PATH = os.path.join(SCRIPT_DIR, \"temp_announcement.txt\")\nANNOUNCEMENT_WAV_PATH = os.path.join(SCRIPT_DIR, \"temp_announcement.wav\")\n\n# --- UTILITIES ---\n\ndef get_playlist(file_path):\n    \"\"\"Reads the playlist file and returns a shuffled list of file paths.\"\"\"\n    try:\n        with open(file_path, 'r', encoding='utf-8') as f:\n            tracks = [line.strip() for line in f if line.strip()]\n        random.shuffle(tracks)\n        return tracks\n    except FileNotFoundError:\n        print(f\"Error: Playlist file not found at {file_path}\")\n        return []\n\ndef get_artist_title(track_path):\n    \"\"\"Simple parser to extract Artist - Title from a filename.\"\"\"\n    base_name = os.path.basename(track_path)\n    name_no_ext = os.path.splitext(base_name)[0].strip()\n    match = re.match(r'^(.*?)\\s*-\\s*(.*)$', name_no_ext) \n    if match:\n        return match.group(1).strip(), match.group(2).strip()\n    return \"Unknown Artist\", name_no_ext\n\ndef generate_announcement_text(artist, title):\n    \"\"\"Generates a simple announcement text.\"\"\"\n    # This can be expanded later to include more VB5-like logic.\n    return f\"Hello, this is Radio Worm. Up next is {artist} with their song, {title}. Stay tuned.\"\n\n\ndef get_announcer_file(artist, title):\n    \"\"\"\n    Generates and caches the announcement file using local SAPI via PowerShell.\n    \"\"\"\n    announcement_text = generate_announcement_text(artist, title)\n    \n    # 1. Define the required unique announcement MP3 file path in the cache\n    announcer_filename = re.sub(r'[^a-zA-Z0-9]', '_', announcement_text)[:40] + \".mp3\"\n    dynamic_announcer_path = os.path.join(SCRIPT_DIR, \"cache\", announcer_filename)\n\n    # 2. Check if the final MP3 file already exists (cache hit)\n    if os.path.exists(dynamic_announcer_path):\n        print(f\"Using cached announcement: {announcer_filename}\")\n        return dynamic_announcer_path\n    \n    print(f\"\\n---> Generating new announcement for: {artist} - {title}\")\n    os.makedirs(os.path.join(SCRIPT_DIR, \"cache\"), exist_ok=True)\n    \n    # --- Step A: Write text to temporary file ---\n    with open(ANNOUNCEMENT_TEXT_PATH, 'w', encoding='utf-8') as f:\n        f.write(announcement_text)\n    \n    # --- Step B: Convert text to WAV using PowerShell SAPI ---\n    # We use a temp WAV file for SAPI output\n    powershell_cmd = f\"$speak = New-Object -ComObject 'SAPI.SpVoice'; $stream = New-Object -ComObject 'SAPI.SpFileStream'; \"\n    powershell_cmd += f\"$stream.Open('{ANNOUNCEMENT_WAV_PATH}', 3, $false); $speak.AudioOutputStream = $stream; \"\n    powershell_cmd += f\"$voice = $speak.GetVoices() | Where-Object {{ $_.GetAttribute('Language') -eq '409' -and $_.GetDescription() -eq 'Microsoft Zira Desktop - English (United States)' }}; \"\n    powershell_cmd += f\"$speak.Voice = $voice; $speak.Speak([System.IO.File]::ReadAllText('{ANNOUNCEMENT_TEXT_PATH}')); $stream.Close(); $speak = $null;\"\n    \n    sapi_command = [\"powershell\", \"-Command\", powershell_cmd]\n    \n    try:\n        subprocess.run(sapi_command, check=True, capture_output=True, text=True)\n        print(\"SAPI conversion successful.\")\n    except subprocess.CalledProcessError as e:\n        print(f\"SAPI Error: {e.stderr}\")\n        return None\n    \n    # --- Step C: Convert temporary WAV to final MP3 using FFmpeg ---\n    ffmpeg_encode_command = [\n        FFMPEG_BIN,\n        \"-i\", ANNOUNCEMENT_WAV_PATH,\n        \"-c:a\", \"libmp3lame\",\n        \"-b:a\", \"192k\",\n        dynamic_announcer_path\n    ]\n    \n    try:\n        subprocess.run(ffmpeg_encode_command, check=True, capture_output=True)\n        print(f\"MP3 encoding successful, saved to cache: {announcer_filename}\")\n        # Cleanup temporary WAV file\n        os.remove(ANNOUNCEMENT_WAV_PATH)\n        return dynamic_announcer_path\n    except subprocess.CalledProcessError as e:\n        print(f\"FFmpeg Encoding Error: {e.stderr.decode('utf-8')}\")\n        return None\n    \n# --- MAIN STREAMING LOGIC ---\n\ndef stream_radio():\n    # ... (rest of stream_radio remains the same, except for the new announcement function)\n    print(\"Starting Pipe-Writer (FFmpeg Segment Generator)...\")\n    \n    os.makedirs(os.path.join(SCRIPT_DIR, \"cache\"), exist_ok=True)\n\n    tracks = get_playlist(PLAYLIST_FILE)\n    if not tracks:\n        print(\"Playlist is empty. Exiting.\")\n        return\n\n    track_cycle = cycle(tracks)\n    \n    for track_path in track_cycle:\n        try:\n            artist, title = get_artist_title(track_path)\n            # The announcement logic is now dynamic (SAPI-based)\n            announcer_file = get_announcer_file(artist, title) \n            \n            # 1. Create FFmpeg Concat List\n            segment_files = []\n            if announcer_file:\n                segment_files.append(announcer_file)\n            segment_files.append(track_path)\n\n            with open(CONCAT_LIST_PATH, 'w', encoding='utf-8') as f:\n                for file in segment_files:\n                    safe_file = file.replace('\\\\', '/').replace(\"'\", r\"'\\''\")\n                    f.write(f\"file '{safe_file}'\\n\")\n\n            # 2. FFmpeg command to output the raw MP3 data to stdout\n            ffmpeg_command = [\n                FFMPEG_BIN,\n                \"-f\", \"concat\",\n                \"-safe\", \"0\", \n                \"-re\", \n                \"-i\", CONCAT_LIST_PATH,\n                \"-c:a\", \"libmp3lame\",\n                \"-b:a\", \"192k\",\n                \"-f\", \"mp3\",\n                \"pipe:1\" # Output to stdout/pipe\n            ]\n\n            print(f\"\\n---> Streaming Segment: {', '.join(os.path.basename(f) for f in segment_files)}\")\n            \n            subprocess.run(ffmpeg_command, check=True)\n            \n        except subprocess.CalledProcessError as e:\n            print(f\"FFmpeg Segment Error (Code {e.returncode}): Segment encoding failed.\")\n            continue\n        except Exception as e:\n            print(f\"CRITICAL LOOP EXCEPTION: Script crashed during processing: {e}\")\n            continue \n\nif __name__ == \"__main__\":\n    stream_radio()